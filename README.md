# Idris で定理証明をやっていく
## 最終目標
直観主義論理（排中律を使わない）で素数の無限性を証明する

# 方針
## できるだけPrelude(標準ライブラリ)の機能を使わず自分で定義していく

## Prelude.Nat(自然数型)を使わない

そもそもここが一番楽しいところなので、自分で定義していく。

``` idris
data N = O | S N
```

見やすさを重視してZではなくOをゼロとした。(Zは整数型に使いたいし)

``` idris
prefix 11 `S`
```

とすると、S (S n)をSの演算子の優先順位が強くなってS S nと書けて地味にうれしい。
(11は99とかでもいい。Haskellでは演算子の優先度は9が最大のようだが、Idrisでは違うみたい)

## 論理和にEitherを使わない 

Either は Left と Right の文字数が揃わないし文字数が多いので
``` idris
data (||) a b = L a | R b
```
と定義して使う。

数学記号と近づけたければ、入力がしづらいが
``` idris
a \/ b
```
としてもいいかもしれない。

## 識別子には日本語を積極的に使って分かりやすくする 
定理証明プログラミングは、数学の難しさがあり、さらに数学よりも記述の柔軟性が無いバージョンなので、そもそも書くのも読むのも難しい。

用語を無理に英語にするとハードルが上がるのでかっこつけない。

# ここまでやった

## reverseのreverseは元通り
done/reverse-reverse.idr

素数とは特に関係ないが練習でやってみた。

## 論理学
logic.idr

### 古典論理と直観主義論理のギャップ

排中律は、公理として認めないと導き出せない。

排中律と同値である（お互いに導き出せる）いくつかの命題があり、それを確かめた。

- ならば(論理包含 =>)をORに変換
- 二重否定の除去

排中律と同値ないくつかの命題

### ド・モルガン論理
排中律や直観論理主義を調べているうちに、ド・モルガン論理というものを知った。
古典論理と直観主義論理の中間にある論理。

- ド・モルガンNAND規則は弱排中律と等価であること
- 「弱排中律を仮定したときに排中律が導ける」と仮定すると、そもそも最初から排中律（それと同値な二重否定除去）を証明できること（つまり、弱排中律を仮定しただけでは排中律は導出できず、ド・モルガン論理は古典論理より弱いこと）

ことを証明した。

## 自然数
いまのところすべて直観主義論理（排中律を使わない）で進めている。

### 自然数を定義
- ペアノの公理
- 自然数の排中律(a=b OR a!=b)

### 和
- 和の定義
- 結合則
- 交換則

### 積
- 積の定義
- 結合則
- 交換則
- (和と積の)分配則

### 不等号
- 不等号の、再帰的な定義
- 不等号の、差となる自然数が存在する定義
- 上記2つの定義の同値性

### 素数の無限性
- 割り切ることの定義
- n>1について、na+1はnでは割り切れないこと
- 素数の定義
- 2が素数であること等
- その他の性質

重要なパーツ(na+1はn>1で割り切れない)の証明はできたが、無限性の証明はまだできていない。

どうも有限集合を先に作る必要がありそうな雰囲気。。
(Idrisの標準ライブラリには有限集合は無さそう

## 整数
z.idr (もともとnat.idrに書いていたものを避難コピーしただけなので、そのままでは動かない)

### 整数を定義
便宜上+0と-0を導入してそれぞれ無限方向に伸ばした上で、+0=-0と定義した。

(Preludeの整数定義では、0→+∞の正方向と、-1→-∞の負方向で定義しているが、正と負で1ずつずれるのが気に入らなかった)

### 和や積を定義
自然数と同様の法則が成り立つことも証明。

### 差を定義
整数の導入(自然数に負の整数を加える)は、そもそも引き算をうまく定義したいというモチベーションから来ている。


